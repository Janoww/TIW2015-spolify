= Music Playlist Application - Design Specification (Javascript version)
:sectnums: |,all|
:doctype: book
:title-logo-image: image:resources/SpolifyIcon.png[top=25%,align=center,pdfwidth=40vw]
:toc: auto
:icons: font
:source-highlighter: coderay

== Introduction

This document outlines the design for a web-based music playlist management application. Users can upload songs, organize them into playlists, and play them. This specification focuses on the Single Page Application (SPA) version, providing a seamless user experience without full page reloads.

*Technology Stack:*

* *Frontend:* HTML, CSS, JavaScript (Vanilla JS)
* *Backend:* Java Servlets (running on Apache Tomcat 10.1)
* *Database:* MySQL
* *API Format:* RESTful APIs exchanging mostly JSON data but `multipart` or other media types for audio and images

== Architecture

The application follows a standard client-server SPA architecture:

plantuml::puml/architecture/component_diagram.puml[svg]

* *Frontend:* A single HTML page dynamically updated using JavaScript. It handles user interactions, makes asynchronous requests (e.g., using `fetch` API) to the backend, and updates the DOM accordingly.
* *Backend:* Java Servlets expose RESTful API endpoints. They handle business logic, interact with the Data Access Object (DAO) layer, and manage user sessions.
* *DAO Layer:* Java classes responsible for interacting with the MySQL database (CRUD operations).
* *Database:* MySQL stores user data, song metadata, album information, and playlist structures.

<<<

== Database Schema

=== Data Analysis

====
Entities:: [.entities]#Entities for the database#
Attributes:: [.attributes]#Attributes for each entities#
Relationships:: [.relationships]#Relationships between entities#
====

Un’applicazione web consente la gestione di una playlist di brani musicali.
[.entities]#Playlist e brani# sono [.relationships]#personali# di ogni [.entities]#utente# e [.relationships]#non condivisi#.

Ogni utente ha [.attributes]#username, password, nome e cognome#.

Ogni brano musicale è memorizzato nella base di dati mediante un [.attributes]#titolo#, l‘[.attributes]#immagine e il titolo# dell’[.entities]#album# da cui il brano è [.relationships]#tratto#, il [.attributes]#nome dell’interprete# (singolo o gruppo) dell’album, l’[.attributes]#anno di pubblicazione# dell’album, il [.attributes]#genere musicale# (si supponga che i generi siano prefissati) e il [.attributes]#file musicale#.
Non è richiesto di memorizzare l’ordine con cui i brani compaiono nell’album a cui appartengono.

Si ipotizzi che un brano possa [.relationships]#appartenere# a un solo album (no compilation).
L’utente, previo login, può [.relationships]#creare# brani mediante il caricamento dei dati relativi e raggrupparli in playlist.

Una playlist è un insieme di brani [.relationships]#scelti# tra quelli caricati dallo stesso utente.
Lo stesso brano può essere [.relationships]#inserito in più# playlist.
Una playlist ha un [.attributes]#titolo# e una [.attributes]#data di creazione# ed è [.relationships]#associata# al suo creatore.

<<<

=== Database design

The database consists of the following tables:

plantuml::puml/architecture/erd.puml[svg]

* *User:* Stores user credentials and basic information.

[source, SQL]
----
CREATE TABLE `User` (
  `idUser` binary(16) NOT NULL,
  `username` varchar(100) NOT NULL,
  `password` varchar(100) NOT NULL,
  `name` varchar(100) DEFAULT NULL,
  `surname` varchar(100) DEFAULT NULL,
  PRIMARY KEY (`idUser`),
  UNIQUE KEY `username_UNIQUE` (`username`)
)
----

* *Album:* Stores album details.

[source, SQL]
----
CREATE TABLE `Album` (
  `idAlbum` int NOT NULL AUTO_INCREMENT,
  `name` varchar(100) NOT NULL,
  `year` int NOT NULL,
  `artist` varchar(100) NOT NULL,
  `image` varchar(255) DEFAULT NULL,
  `idUser` binary(16) NOT NULL,
  PRIMARY KEY (`idAlbum`),
  UNIQUE KEY `unique_name_per_user` (`name`,`idUser`),
  KEY `fk_Album_1_idx` (`idUser`),
  CONSTRAINT `fk_Album_1` FOREIGN KEY (`idUser`) REFERENCES `User` (`idUser`) ON DELETE CASCADE ON UPDATE CASCADE
)
----

* *Song:* Stores song metadata and file paths.

[source, SQL]
----
CREATE TABLE `Song` (
  `idSong` int NOT NULL AUTO_INCREMENT,
  `title` varchar(100) NOT NULL,
  `idAlbum` int NOT NULL,
  `genre` varchar(100) DEFAULT NULL,
  `audioFile` varchar(255) NOT NULL,
  `idUser` binary(16) NOT NULL,
  PRIMARY KEY (`idSong`),
  KEY `fk_Song_2_idx` (`idAlbum`),
  KEY `fk_Song_1_idx` (`idUser`),
  CONSTRAINT `fk_Song_1` FOREIGN KEY (`idUser`) REFERENCES `User` (`idUser`) ON DELETE CASCADE ON UPDATE CASCADE,
  CONSTRAINT `fk_Song_2` FOREIGN KEY (`idAlbum`) REFERENCES `Album` (`idAlbum`) ON DELETE CASCADE ON UPDATE CASCADE
)
----

* *playlist_metadata:* Stores playlist metadata.

[source, SQL]
----
CREATE TABLE `playlist_metadata` (
  `idPlaylist` int NOT NULL AUTO_INCREMENT,
  `name` varchar(100) NOT NULL,
  `birthday` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `idUser` binary(16) NOT NULL,
  PRIMARY KEY (`idPlaylist`),
  UNIQUE KEY `unique_playlist_per_user` (`idUser`,`name`),
  KEY `fk_playlist-metadata_1_idx` (`idUser`),
  CONSTRAINT `fk_playlist-metadata_1` FOREIGN KEY (`idUser`) REFERENCES `User` (`idUser`) ON DELETE CASCADE ON UPDATE CASCADE
)
----

* *playlist_content:* Joining table for the N-N relationship between `playlist_metadata` and `Song`.

[source, SQL]
----
CREATE TABLE `playlist_content` (
  `idPlaylist` int NOT NULL,
  `idSong` int NOT NULL,
  PRIMARY KEY (`idPlaylist`,`idSong`),
  UNIQUE KEY `unique_playlist_and_song` (`idSong`,`idPlaylist`),
  KEY `fk_playlist-content_1_idx` (`idSong`),
  KEY `fk_playlist-content_2_idx` (`idPlaylist`),
  CONSTRAINT `fk_playlist-content_1` FOREIGN KEY (`idSong`) REFERENCES `Song` (`idSong`) ON DELETE CASCADE ON UPDATE CASCADE,
  CONSTRAINT `fk_playlist-content_2` FOREIGN KEY (`idPlaylist`) REFERENCES `playlist_metadata` (`idPlaylist`) ON DELETE CASCADE ON UPDATE CASCADE
)
----

NOTE: The 'year' for a song is derived from its associated Album's year.

<<<

== Application design

=== Application requirements analysis

====
Pages (views):: [.pages]#The views for the front end#
View components:: [.components]#The view components for each view#
Events:: [.events]#The events needed to handle#
Actions:: [.actions]#The user actions to capture#
====

A seguito del [.events]##lo##[.actions]##gin##, l’utente accede all’[.pages]#HOME PAGE# che presenta l’[.components]#elenco delle proprie playlist#, ordinate per data di creazione decrescente, un [.components]#form per caricare un brano# con tutti i dati relativi e un [.components]#form per creare una nuova playlist#.

[.components]#Il form per la# [.events]#creazione# di una nuova playlist mostra l’[.components]#elenco dei brani# dell’utente ordinati per ordine alfabetico crescente dell’autore o gruppo e per data crescente di pubblicazione dell’abum a cui il brano appartiene.
Tramite il form è possibile [.actions]#selezionare uno o più brani# da includere.

Quando l’utente [.events]#clicca# [.actions]#su una playlist# nell’HOME PAGE, appare la pagina [.pages]#PLAYLIST PAGE# che contiene inizialmente [.components]#una tabella# di una riga e cinque colonne.
Ogni [.components]#cella contiene il titolo di un brano e l’immagine# dell’album da cui proviene.
I brani sono ordinati da sinistra a destra per ordine alfabetico crescente dell’autore o gruppo e per data crescente di pubblicazione dell’abum a cui il brano appartiene.

Se la playlist contiene più di cinque brani, sono disponibili comandi per vedere il [.events]#precedente e successivo# gruppo di brani.
Se la PLAYLIST PAGE mostra il primo gruppo e ne esistono altri successivi nell’ordinamento, compare a destra della riga il [.components]#bottone SUCCESSIVI#, che permette di vedere il gruppo successivo.
Se la PLAYLIST PAGE mostra l’ultimo gruppo e ne esistono altri precedenti nell’ordinamento, compare a sinistra della riga il [.components]#bottone PRECEDENTI#, che permette di vedere i cinque brani precedenti.
Se la PLAYLIST PAGE mostra un blocco e esistono sia precedenti sia successivi, compare a destra della riga il bottone SUCCESSIVI e a sinistra il bottone PRECEDENTI.

La PLAYLIST PAGE contiene anche un [.components]#form che consente di selezionare e aggiungere uno o più brani# alla playlist corrente, se non già presente nella playlist.
Tale form presenta i brani da scegliere nello stesso modo del form usato per creare una playlist.
A seguito dell’[.events]#aggiunta di un brano# alla playlist corrente, l’applicazione visualizza nuovamente la pagina a partire dal primo blocco della playlist.

Quando l’utente seleziona il titolo di un brano, la [.pages]#PLAYER PAGE# mostra tutti i [.components]#dati del brano# scelto e il [.components]#player audio# per la [.events]#riproduzione del brano#.

==== Javascript specific requirements

Si realizzi un’applicazione client server web che modifica le specifiche precedenti come segue:

* Dopo il login dell’utente, l’intera applicazione è realizzata con un’unica pagina.
* Ogni interazione dell’utente è gestita senza ricaricare completamente la pagina, ma produce l’[.events]#invocazione asincrona# del server e l’eventuale modifica del contenuto da aggiornare a seguito dell’evento.
* L’evento di [.events]#visualizzazione del blocco# precedente/successivo è gestito a lato client senza generare una
  richiesta al server.
* L’applicazione deve consentire all’utente di [.events]#riordinare le playlist# con un criterio personalizato diverso da
  quello di default.
  Dalla HOME con un link associato a ogni playlist si accede a una [.pages]#finestra modale RIORDINO#,
  che mostra la [.components]#lista completa dei brani# della playlist ordinati secondo il criterio corrente (personalizzato o di
  default).
  L’utente può [.actions]#trascinare# il titolo di un brano nell’elenco e di [.actions]#collocarlo# in una posizione diversa per
  realizzare l’ordinamento che desidera, senza invocare il server. Quando l’utente ha raggiunto l’ordinamento
  desiderato, usa un bottone [.events]#“salva ordinamento”#, per memorizzare la sequenza sul server. Ai successivi
  accessi, l’ordinamento personalizzato è usato al posto di quello di default. Un brano aggunto a una playlist
  con ordinamento personalizzato è inserito nell’ultima posizione.

==== Additional Implemented JavaScript Features

===== Functional Additions
* A [.components]#global, persistent audio player UI# is visible after login, featuring a dedicated interface and a [.events]#close button#.
* A [.pages]#dedicated "Songs" page# allows users to [.actions]#view a complete list# of all their tracks.
* The [.components]#main navigation bar# is dynamically populated with navigation links.
* [.actions]#Selecting a song# from any list (e.g., from the playlist view or Songs view) [.events]#dynamically activates# the global audio player functionality, updating its details and loading the audio track, rather than navigating to a separate static page for playback.
* The dynamically populated [.components]#main navigation bar# also includes a [.components]#logout button#; [.events]#clicking# this button [.actions]#initiates the logout process# by calling the relevant API service.

===== Non-Functional Aspects
* User session management utilizes `sessionStorage` for persistence of authenticated user data.
* For security, the DOMPurify library is used to [.actions]#sanitize inputs# before rendering them in the DOM.
* During page transitions managed by the router, a [.components]#visual loader# enhances user experience.
* The `apiService.js` module centralizes backend communication, implementing robust error handling via custom `ApiError` objects, and providing utility functions such as URL builders for media resources (song images and audio). This promotes maintainability and reusability.

* *Color Palette:*
** Background color: image:../palette/EEEEEE.svg[Background] #EEEEEE
** Alternative background color: image:../palette/D4BEE4.svg[Alt Background] #D4BEE4
** Text: image:../palette/9B7EBD.svg[Text] #9B7EBD
** Highlight color: image:../palette/3B1E54.svg[High Text] #3B1E54.

<<<

=== Frontend Component Diagram

plantuml::puml/architecture/frontend_component_view_diagram.puml[svg]

=== Frontend Views, Components, Events, and Actions Summary

==== Global Components & Interactions (SPA Shell)

*Components:*

* [.components]#Global Navigation Bar#: Dynamically populated with "Home", "Songs" links, and "Logout" button.
* [.components]#Global Persistent Audio Player UI#: Displays song title, artist, album, year, genre, album cover, and HTML5 audio controls. Includes a close button.
* [.components]#Visual Loader#: Displayed during route transitions.

*Events/Actions:*

* [.events]#Navigation link click# in navbar: [.actions]#Routes to the corresponding view# (e.g., `home`, `songs`).
* [.events]#Logout button click# in navbar: [.actions]#Initiates user logout process#.
* [.events]#Song selection# (from any song list): [.actions]#Dynamically updates the Global Audio Player# with the selected song's details and loads its audio track. Player UI becomes visible if hidden.
* [.events]#Player Close Button click#: [.actions]#Hides the Global Audio Player UI#.
* Standard HTML5 audio player interactions (play, pause) within the Global Audio Player.

==== Login/Signup View (Routes: `#login`, `#signup`)

*Components:*

* [.components]#Login Form#: Inputs for username, password; submit button. Link to Signup.
* [.components]#Signup Form#: Inputs for username, password, name, surname; submit button. Link to Login.

*Events/Actions:*

* [.events]#Login Form submission#: [.actions]#Sends credentials to backend#.
* [.events]#Signup Form submission#: [.actions]#Sends user data to backend#.
* [.events]#"Switch to Signup/Login" link click#: [.actions]#Navigates to the other authentication form#.

==== Home View (Route: `#home`)

*Components:*

* [.components]#User's Playlist List#: Displays each playlist with its name. Includes a "Reorder" button/link for each playlist.
* [.components]#Song Upload Form#: Inputs for song title, genre, album title, album artist, album year, audio file, and optional album image. Submit button.
* [.components]#Playlist Creation Form#: Input for playlist name. [.components]#List of user's available songs# with checkboxes for selection. Submit button.

*Events/Actions:*

* [.events]#Playlist name click# in list: [.actions]#Navigates to the Playlist View# for that specific playlist (e.g., `playlist-123`).
* [.events]#"Reorder" button/link click# for a playlist: [.actions]#Opens the Reorder Modal# populated with songs from that playlist.
* [.events]#Song Upload Form submission#: [.actions]#Sends form data to backend#.
* [.events]#Playlist Creation Form submission#: [.actions]#Sends new playlist name and selected song IDs to backend#.

==== Songs View (Route: `#songs`)

*Components:*

* [.components]#Comprehensive List of User's Songs#: Displays all songs uploaded by the user, showing details like title, artist, and album.
* [.components]#Song Upload Form#: Inputs for song title, genre, album title, album artist, album year, audio file, and optional album image. Submit button.

*Events/Actions:*

* [.events]#Song item click/selection# in the list: [.actions]#Activates/updates the Global Persistent Audio Player# with the selected song's details and audio.
* [.events]#Song Upload Form submission#: [.actions]#Sends form data to backend#.

==== Playlist View (Route: `#playlist-:idplaylist`)

*Components:*

* [.components]#Playlist Song List#: Displays songs belonging to the selected playlist.
* [.components]#"Previous" and "Next" Pagination Buttons#: For client-side navigation through the playlist's songs.
* [.components]#Add Songs to Playlist Form#: [.components]#List of user's available songs# with checkboxes for selection. Submit button.

*Events/Actions:*

* [.events]#Song item click/selection# in the playlist: [.actions]#Activates/updates the Global Persistent Audio Player#.
* [.events]#"Previous"/"Next" button click#: [.actions]#Updates the displayed slice of songs# from the client-side cached list for the current playlist (client-side pagination).
* [.events]#Add Songs Form submission#: [.actions]#Sends selected song IDs to backend# to add to the current playlist.

==== Reorder Modal (Dialog)

*Components:*

* [.components]#Complete list of songs# for the selected playlist, with draggable items displaying song titles.
* [.components]#"Save Order" button#.
* [.components]#Close button#.
* [.components]#Cancel button#.

*Events/Actions:*

* [.events]#drag and drop song items# within the list: [.actions]#Client-side reordering of the song list display# (visual update of the order).
* [.events]#"Save Order" button click#: [.actions]#Sends the new sequence of song IDs to the backend#.
* [.events]#Close button click#: [.actions]#Closes the modal# without saving changes.
* [.events]#Cancel button click#: [.actions]#Resets the current user unsaved order changes#.

<<<

== Application Flow Sequence Diagrams

This section details the various user interaction and backend API flows within the Music Playlist Application using sequence diagrams. Each diagram illustrates a specific process or functionality, showing the communication between frontend components, backend servlets, and data access objects.

=== Login and Signup Page Flow Sequence Diagram

This sequence diagram details the user interaction flow for both login and signup processes.

plantuml::puml/flows/login_signup_flow.puml[svg]

<<<

=== Home Page Flow Sequence Diagram

This sequence diagram outlines the sequence of events when a user navigates to the home page.

plantuml::puml/flows/home_page_flow.puml[svg]

<<<

=== Songs Page Flow Sequence Diagram

This sequence diagram illustrates the flow when a user navigates to the "Songs" page.

plantuml::puml/flows/songs_page_flow.puml[svg]

<<<

=== Playlist Page Flow Sequence Diagram

This sequence diagram details the interactions on the playlist page.

plantuml::puml/flows/playlist_page_flow.puml[svg]

<<<

=== Global Player Flow Sequence Diagram

This sequence diagram explains how the global audio player is activated and controlled.

plantuml::puml/flows/player_flow.puml[svg]

<<<

=== Reorder Playlist Modal Flow Sequence Diagram

This sequence diagram outlines the process of reordering songs within a playlist using a modal.

plantuml::puml/flows/reorder_modal_flow.puml[svg]

<<<

=== Authentication API Flow Sequence Diagram

This sequence diagram illustrates the backend API interactions for user authentication, including login, logout, and session status checking.

plantuml::puml/flows/auth_api_flow.puml[svg]

=== User Registration API Flow Sequence Diagram

This sequence diagram focuses on the backend API interaction for new user registration.

plantuml::puml/flows/user_api_flow.puml[svg]

<<<

=== Song Management API Flow Sequence Diagram

This sequence diagram details the backend API interactions for song management.

plantuml::puml/flows/song_api_flow.puml[svg]

<<<

=== Playlist Management API Flow Sequence Diagram

This sequence diagram illustrates the backend API interactions for playlist management.

plantuml::puml/flows/playlist_api_flow.puml[svg]

<<<

== API Endpoints (Servlets)

The backend will expose RESTful API endpoints, all prefixed with `/api/v1/`. The primary servlets and their functionalities are:

=== Authentication & User Management

* `POST /auth/login`: Authenticates an existing user.
====
*Request:* JSON.

plantuml::puml/api/login_request.puml[svg]

*Response (200 OK):* On success, returns JSON and sets an HTTP session cookie.

plantuml::puml/api/user_info_response.puml[svg]

*Error Responses:*

* `400 Bad Request`: Invalid input (e.g., missing fields, invalid format).
* `401 Unauthorized`: Incorrect credentials.
* `500 Internal Server Error`: Server-side error.
====

* `POST /users`: Registers a new user.
====
*Request:* JSON.

plantuml::puml/api/user_creation_request.puml[svg]

*Response (201 CREATED):* On success, returns JSON and sets an HTTP session cookie.

plantuml::puml/api/user_info_response.puml[svg]

*Error Responses:*

* `400 Bad Request`: Invalid input or validation errors.
* `409 Conflict`: Username already exists.
* `500 Internal Server Error`: Server-side error.
====

* `POST /auth/logout`: Logs out the currently authenticated user.
====
*Request:* No body required.

*Response (200 OK):* Returns JSON. Invalidates the user's HTTP session.

plantuml::puml/api/logout_response.puml[svg]

*Error Responses:*

* `500 Internal Server Error`: If an unexpected server error occurs during logout.
====

* `GET /auth/me`: Checks if the current user has an active session.
====
*Request:* No body required.

*Response (200 OK):* If a session is active, returns JSON.

plantuml::puml/api/user_info_response.puml[svg]

*Error Responses:*

* `401 Unauthorized`: No active session.
====

=== Songs

* `GET /songs`: Fetches all songs for the authenticated user.
====
*Request:* No body required.

*Response (200 OK):* JSON array of `SongWithAlbum` objects. Each object includes full song details and associated album details.

plantuml::puml/api/song_with_album_list_response.puml[svg]

*Error Responses:*

* `401 Unauthorized`: User not authenticated.
* `500 Internal Server Error`: Server-side error.
====

* `POST /songs`: Uploads a new song. If an album with the provided `albumTitle` doesn't exist for the user, a new album is created.
====
*Request:* `multipart/form-data` containing:

* `title` (text, required): The title of the song.
* `genre` (text, required): The genre of the song (must be one of the predefined values, see `GET /songs/genres`).
* `albumTitle` (text, required): The title of the album.
* `albumArtist` (text, required): The artist of the album.
* `albumYear` (number, required): The year of the album.
* `audioFile` (file, required): The audio file for the song (e.g., `audio.mp3`).
* `albumImage` (file, optional): The cover image for the album (e.g., `cover.jpg`). This is used if a new album is being created and this part is provided.

*Response (201 CREATED)*: JSON `SongWithAlbum` object representing the newly created song and its (potentially new) album.

plantuml::puml/api/song_with_album_response.puml[svg]

*Error Responses:*

* `400 Bad Request`: Invalid input (e.g., missing required fields, invalid genre, invalid year format, file processing error).
* `401 Unauthorized`: User not authenticated.
* `409 Conflict`: If a constraint violation occurs (e.g., song title already exists in the album for that user, though this specific check might vary based on DAO implementation).
* `500 Internal Server Error`: Server-side error (e.g., DAO exception, file storage issue).
====

* `GET /songs/genres`: Fetches all available song genres.
====
*Request:* No body required.

*Response (200 OK):* JSON array of objects, where each object has a `name` (e.g., "ROCK") and `description` (e.g., "Rock Music") for the genre.

plantuml::puml/api/genre_list_response.puml[svg]

*Error Responses:*

* `401 Unauthorized`: User not authenticated (if authentication is enforced for this endpoint, though typically it might be public).
* `500 Internal Server Error`: Server-side error.
====

* `GET /songs/{songId}`: Fetches details for a specific song, identified by `songId`.
====
*Request:* No body required.

*Response (200 OK):* JSON `SongWithAlbum` object containing full song details and associated album details.

plantuml::puml/api/song_with_album_response.puml[svg]

*Error Responses:*

* `400 Bad Request`: Invalid `songId` format.
* `401 Unauthorized`: User not authenticated.
* `404 Not Found`: Song not found or not owned by the user.
* `500 Internal Server Error`: Server-side error.
====

* `GET /songs/{songId}/audio`: Fetches the audio file for a specific song.
====
*Request:* No body required.

*Response (200 OK):* The audio file stream (e.g., `audio/mpeg`, `audio/ogg`) with appropriate `Content-Type` and `Content-Disposition` headers.

*Error Responses:*

* `400 Bad Request`: Invalid `songId` format.
* `401 Unauthorized`: User not authenticated.
* `404 Not Found`: Song not found, not owned by the user, or audio file is missing.
* `500 Internal Server Error`: Server-side error (e.g., error reading file).
====

* `GET /songs/{songId}/image`: Fetches the album cover image for the album associated with a specific song.
====
*Request:* No body required.

*Response (200 OK):* The image file stream (e.g., `image/jpeg`, `image/png`) with appropriate `Content-Type` and `Content-Disposition` headers.

*Error Responses:*

* `400 Bad Request`: Invalid `songId` format.
* `401 Unauthorized`: User not authenticated.
* `404 Not Found`: Song not found, album not found, not owned by the user, or image file is missing.
* `500 Internal Server Error`: Server-side error (e.g., error reading file).
====

=== Playlists

* `GET /playlists`: Fetches all playlists for the authenticated user.
====
*Request:* No body required.

*Response (200 OK):* JSON array of `Playlist` objects.

plantuml::puml/api/playlist_list_response.puml[svg]

*Error Responses:*

* `401 Unauthorized`: User not authenticated.
* `500 Internal Server Error`: Server-side error.
====

* `POST /playlists`: Creates a new playlist.
====
*Request:* JSON (songIds is optional, if provided must be an array of positive integers).

plantuml::puml/api/playlist_creation_request.puml[svg]

*Response (201 CREATED)*: On success, returns the created `Playlist` object.

plantuml::puml/api/playlist_response.puml[svg]

*Error Responses:*

* `400 Bad Request`: Invalid input (e.g., missing name, invalid name format, invalid song IDs).
* `401 Unauthorized`: User not authenticated.
* `409 Conflict`: Playlist name already exists for the user.
* `500 Internal Server Error`: Server-side error (e.g., DAO exception).
====

* `POST /playlists/{playlistId}/songs`: Adds one or more songs to an existing playlist.
====
*Request:* JSON. `songIds` must be a non-empty array of positive integers.

plantuml::puml/api/playlist_add_songs_request.puml[svg]

*Response (200 OK):* On successful processing, returns JSON:

plantuml::puml/api/add_songs_to_playlist_response.puml[svg]

*Error Responses:*

* `400 Bad Request`: Invalid JSON, missing/empty `songIds`, invalid song ID format.
* `401 Unauthorized`: User not authenticated.
* `403 Forbidden`: User does not own the playlist, or a specified song is not owned by the user.
* `404 Not Found`: Playlist with `+{playlistId}+` not found, or a specified song ID not found.
* `500 Internal Server Error`: Other server-side errors.
====

* `GET /playlists/{playlistId}/order`: Fetches the current order of songs for a specific playlist.
====
*Request:* No body required.

*Response (200 OK):* JSON array of song IDs representing the order.

plantuml::puml/api/song_id_list_response.puml[svg]

*Error Responses:*

* `400 Bad Request`: Invalid playlist ID format.
* `401 Unauthorized`: User not authenticated.
* `404 Not Found`: Playlist not found or user does not have access.
* `500 Internal Server Error`: Other server-side errors.
====

* `PUT /playlists/{playlistId}/order`: Updates the order of songs in a specific playlist.
====
*Request:* JSON array of song IDs in the desired new order. The list must contain all and only the song IDs currently in the playlist, without duplicates.

plantuml::puml/api/playlist_update_order_request.puml[svg]

*Response (200 OK):* JSON array of song IDs confirming the new order.

plantuml::puml/api/song_id_list_response.puml[svg]

*Error Responses:*

* `400 Bad Request`: Invalid JSON format, invalid playlist ID, song ID list does not match current playlist content (e.g., missing songs, extra songs, duplicate songs in request, invalid song IDs).
* `401 Unauthorized`: User not authenticated.
* `404 Not Found`: Playlist not found or user does not have access.
* `500 Internal Server Error`: Other server-side errors.
====

_Error Handling:_ APIs should return appropriate HTTP status codes (e.g., 200, 201, 400, 401, 403, 404, 500) and JSON error messages.

<<<

== Data Access Objects (DAOs) and Java Beans Structure

This section outlines the structure of the Data Access Objects (DAOs) responsible for database interactions and file system storage, and the Java Beans used to represent data entities and requests.

=== Data Access Objects (DAOs)

DAOs encapsulate the logic for accessing and manipulating data in the database and file system. Below are the main public methods for each DAO, focusing on their primary responsibilities.

==== `AlbumDAO`
Manages `Album` entities in the database.

* `createAlbum(String name, int year, String artist, String image, UUID idUser)`: Creates a new album.
* `findAlbumById(int idAlbum)`: Retrieves an album by its unique ID.
* `findAllAlbums()`: Retrieves all albums.
* `findAlbumsByUser(UUID userId)`: Retrieves all albums for a specific user.
* `updateAlbum(int idAlbum, UUID userId, String name, Integer year, String artist, String image)`: Updates an existing album's details.
* `deleteAlbum(int idAlbum, UUID userId)`: Deletes an album.

==== `AudioDAO`
Manages audio file storage and retrieval within a dedicated 'song' subfolder.

* `saveAudio(InputStream audioStream, String originalFileName)`: Saves an audio file, validates its content, and returns a unique sanitized filename.
* `deleteAudio(String filename)`: Deletes a specific audio file from storage.
* `getAudio(String filename)`: Retrieves audio file data (stream, name, MIME type, size).

==== `ImageDAO`
Manages image file storage and retrieval, typically for album covers, within a dedicated 'image' subfolder.

* `saveImage(InputStream imageStream, String originalFileName)`: Saves an image file, validates its content, and returns a unique sanitized filename.
* `deleteImage(String filename)`: Deletes a specific image file from storage.
* `getImage(String filename)`: Retrieves image file data (stream, name, MIME type, size).

==== `PlaylistDAO`
Manages `Playlist` entities and their relationship with `Song` entities in the database.

* `createPlaylist(String name, UUID idUser, List<Integer> songIds)`: Creates a new playlist with specified songs, ensuring atomicity via transactions.
* `findPlaylistById(int playlistId, UUID userId)`: Retrieves a specific playlist for a user, including its song IDs.
* `findPlaylistsByUser(UUID idUser)`: Retrieves all playlists for a specific user.
* `deletePlaylist(int playlistId, UUID userId)`: Deletes a playlist and its song associations.
* `addSongToPlaylist(int playlistId, UUID userId, int songId)`: Adds a single song to a playlist, with ownership and existence checks.
* `removeSongFromPlaylist(int playlistId, UUID userId, int songId)`: Removes a song from a playlist.
* `addSongsToPlaylist(int playlistId, UUID userId, List<Integer> songIdsToAdd)`: Adds multiple songs to a playlist transactionally, returning a result object indicating successfully added and duplicate songs.

==== `PlaylistOrderDAO`
Manages the custom ordering of songs within playlists, storing this order information as JSON files in a 'playlist_orders' subfolder.

* `savePlaylistOrder(int idPlaylist, List<Integer> orderedSongIds)`: Saves or updates the custom song order for a playlist.
* `getPlaylistOrder(int idPlaylist)`: Retrieves the custom song order for a playlist; returns an empty list if no custom order exists.
* `deletePlaylistOrder(int idPlaylist)`: Deletes the custom song order file for a playlist.

==== `SongCreationServiceDAO`
Orchestrates the complex, transactional process of creating a new song. This service coordinates `AlbumDAO`, `SongDAO`, `ImageDAO`, and `AudioDAO` to handle album creation (if needed), file uploads (audio and optional album image), and database record insertions.

* `createSongWorkflow(User user, SongCreationParameters params, Part imageFilePart)`: Manages the end-to-end song creation process, including saving files, creating/finding an album, creating the song record, and ensuring transactional integrity with rollbacks and cleanup on failure.

==== `SongDAO`
Manages `Song` entities in the database.

* `createSong(String title, int idAlbum, Genre genre, String audioFile, UUID idUser)`: Creates a new song record.
* `findSongsByUser(UUID userId)`: Retrieves all songs uploaded by a specific user.
* `findAllSongs()`: Retrieves all songs from the database.
* `deleteSong(int songId)`: Deletes a song record.
* `findSongsByIdsAndUser(List<Integer> songIds, UUID userId)`: Retrieves specific songs by their IDs, ensuring they belong to the specified user.

==== `UserDAO`
Manages `User` entities in the database, including authentication and user information.

* `createUser(String username, String pwd, String name, String surname)`: Creates a new user, checking for username uniqueness.
* `findUserByUsername(String username)`: Retrieves a user by their username (excluding password).
* `checkCredentials(String username, String pwd)`: Validates user credentials and returns user details upon success.
* `modifyUser(User user, String name, String surname)`: Modifies a user's name and/or surname.
* `deleteUser(UUID userId)`: Deletes a user from the database.

=== Java Beans

Java Beans (and Records) used throughout the application to model data entities, request payloads, and structured responses.

==== `AddSongsToPlaylistResult`
Represents the outcome of an operation to add multiple songs to a playlist.

`addedSongIds`:: `List<Integer>` - List of IDs for songs that were successfully added to the playlist.
`duplicateSongIds`:: `List<Integer>` - List of IDs for songs that were already present in the playlist and thus not re-added.

==== `Album`
Represents an album entity.

`idAlbum`:: `int` - Unique identifier for the album.
`name`:: `String` - Name of the album.
`year`:: `int` - Release year of the album.
`artist`:: `String` - Artist of the album.
`imageFile`:: `String` - Path to the album's image file (internal use, marked with `@JsonIgnore` for API responses).
`idUser`:: `UUID` - Identifier of the user who owns or created the album.

==== `FileData` (Record)
A record that encapsulates data for a file, including its content stream and essential metadata.

`content`:: `InputStream` - The stream providing the file's content.
`filename`:: `String` - The name of the file.
`mimeType`:: `String` - The MIME type of the file (e.g., "audio/mpeg", "image/jpeg").
`size`:: `long` - The size of the file in bytes.

==== `LoginRequest`
Represents the data structure for a user login request.

`username`:: `String` - The username provided for login.
`password`:: `String` - The password provided for login.

==== `Playlist`
Represents a playlist entity.

`idPlaylist`:: `int` - Unique identifier for the playlist.
`name`:: `String` - Name of the playlist.
`birthday`:: `Timestamp` - Timestamp indicating the creation date and time of the playlist.
`idUser`:: `UUID` - Identifier of the user who owns the playlist.
`songs`:: `List<Integer>` - List of song IDs included in this playlist.

==== `PlaylistAddSongsRequest`
Represents the request payload for adding one or more songs to an existing playlist.

`songIds`:: `List<Integer>` - A list of song IDs to be added to the playlist.

==== `PlaylistCreationRequest`
Represents the data structure for a request to create a new playlist.

`name`:: `String` - The desired name for the new playlist.
`songIds`:: `List<Integer>` - An initial list of song IDs to include in the newly created playlist (can be empty).

==== `Song`
Represents a song entity.

`idSong`:: `int` - Unique identifier for the song.
`title`:: `String` - Title of the song.
`idAlbum`:: `int` - Identifier of the album to which this song belongs.
`genre`:: `Genre` (Enum) - Musical genre of the song (e.g., ROCK, POP).
`audioFile`:: `String` - Path or reference to the song's audio file (internal use, marked with `@JsonIgnore`).
`idUser`:: `UUID` - Identifier of the user who uploaded or owns the song.

==== `SongCreationParameters` (Record)
A record that encapsulates all parameters required for the song creation workflow, typically gathered from a multipart form submission.

`songTitle`:: `String` - Title of the new song.
`albumTitle`:: `String` - Title of the album for the song. If the album doesn't exist for the user, it might be created.
`albumArtist`:: `String` - Artist of the album.
`albumYear`:: `int` - Release year of the album.
`genre`:: `Genre` (Enum) - Genre of the song.
`audioFilePart`:: `Part` - The uploaded audio file part from a multipart/form-data request.

==== `SongWithAlbum`
A composite bean designed to conveniently package a `Song` object along with its associated `Album` object, often used for API responses.

`song`:: `Song` - The song object.
`album`:: `Album` - The album object associated with the song.

==== `User`
Represents a user entity, typically for application-level use after authentication.

`idUser`:: `UUID` - Unique identifier for the user (internal use, marked with `@JsonIgnore`).
`username`:: `String` - The user's username.
`name`:: `String` - The user's first name.
`surname`:: `String` - The user's last name.

==== `UserCreationRequest`
Represents the data structure for a new user registration request.

`username`:: `String` - Desired username for the new user.
`password`:: `String` - Desired password for the new user.
`name`:: `String` - First name of the new user.
`surname`:: `String` - Last name of the new user.

<<<

== Frontend JavaScript Architecture and Structure

The frontend is a Vanilla JavaScript Single Page Application (SPA) built with a modular structure. It dynamically updates the content of `index.html` without full page reloads. The core JavaScript files (`app.js`, `router.js`, `apiService.js`) and the directory structure (`handlers/`, `views/`, `utils/`) define its architecture.

=== Core Modules & Responsibilities

. *`app.js` (Main Entry Point):*

 ** `addNavLinks(navbar)`: Populates the navigation bar with links like "Home" and "Songs".
 ** `checkUserSessionAndInitialize()`: Verifies user authentication status, manages session data in `sessionStorage`, and handles initial page routing based on authentication.
 ** `DOMContentLoaded` event listener: Orchestrates application startup by initializing the router, checking the user session, and setting up the main navigation bar including the logout button.

. *`router.js` (Client-Side Routing):*

 ** `showLoader()`: Displays a visual loader during page transitions.
 ** `hideLoader()`: Hides the visual loader.
 ** `initRouter(containerElement, routeDefinitions, appPublicRoutes)`: Sets up the router with route mappings and attaches a listener for URL hash changes.
 ** `navigate(routeKey)`: Allows programmatic navigation to a specified route.
 ** `handleRouteChange()` (async): Processes URL hash changes, matches them to defined routes, extracts parameters, and invokes the appropriate handler via `executeHandler`. Manages the loader display.
 ** `executeHandler(handler, matchedRoutePattern, params)` (async): Executes the route-specific handler function, manages navbar visibility based on route protection, and handles errors.

. *`apiService.js` (API Communication Layer):*

 ** `_fetchApi(endpoint, options, isFormData)` (async, private helper): Core function for making `fetch` requests to the backend. Handles request/response processing, JSON serialization/parsing, FormData, and error handling (creating `ApiError` objects).
 ** `checkAuthStatus()`: Checks if a user is currently authenticated (`GET /auth/me`).
 ** `login(credentials)`: Sends user credentials to log in (`POST /auth/login`).
 ** `logout()`: Logs out the current user (`POST /auth/logout`).
 ** `signup(userData)`: Registers a new user (`POST /users`).
 ** `getPlaylists()`: Fetches all playlists for the authenticated user (`GET /playlists`).
 ** `createPlaylist(playlistData)`: Creates a new playlist (`POST /playlists`).
 ** `getPlaylistSongOrder(playlistId)`: Retrieves the order of songs in a playlist (`GET /playlists/{playlistId}/order`).
 ** `addSongsToPlaylist(playlistId, songIdsData)`: Adds songs to a specific playlist (`POST /playlists/{playlistId}/songs`).
 ** `updatePlaylistOrder(playlistId, orderedSongIdsData)`: Updates the song order for a playlist (`PUT /playlists/{playlistId}/order`).
 ** `getSongs()`: Fetches all songs for the authenticated user (`GET /songs`).
 ** `uploadSong(formElement)`: Uploads a new song with its details and files using `FormData` (`POST /songs`).
 ** `getSongDetails(songId)`: Fetches details for a specific song (`GET /songs/{songId}`).
 ** `getSongGenres()`: Retrieves the list of available song genres (`GET /songs/genres`).
 ** `getSongImageURL(songId)`: Builds the URL to fetch a song's album image.
 ** `getSongAudioURL(songId)`: Builds the URL to fetch a song's audio file.

=== Directory Structure and Component Roles (`src/main/webapp/js/`)

* *`handlers/` (Controller/Presenter Logic):*

 ** `homeHandler.js`:
  *** `initHomePage(appContainer)`: Initializes the Home Page, loading/rendering components (playlists, song upload, new playlist forms) and setting up event listeners.

 ** `loginHandler.js`:
  *** `initLoginPage(appContainer)`: Initializes and displays the login form, handling its submission.
  *** `initSignupPage(appContainer)`: Initializes and displays the signup form, handling its submission.
  *** `logoutUser()`: Manages user logout, including API call, session clearing, and navigation.

 ** `playerHandler.js`:
  *** `initPlayer()`: Initializes the global audio player UI and event listeners.
  *** `startPlayback(songId, songIdList = [])`: Starts playback for a song, optionally setting up a queue.
  *** `stopPlayback()`: Stops current playback, clears queue, and hides player.

 ** `playlistHandler.js`:
  *** `initPlaylistPage(appContainer, params)`: Initializes the playlist page for a specific playlist, rendering its songs, pagination, and add-song form, and setting up interactions.
  *** `getOrderedSongs(playlist, playlistOrder)`: Fetches and returns full song details in a specified or default order for a playlist.

 ** `sharedFormHandlers.js`:
  *** `handleSongUploadSubmit(event, fieldIds, errorDivId, onSuccessCallback, appContainer, songsList)`: Provides a reusable handler for song upload form submissions, including validation, API call, and success/error handling.

 ** `songsHandler.js`:
  *** `initSongPage(appContainer)`: Initializes the "All Songs" page, fetching and displaying all user songs, the song upload form, and handling related events.

* *`views/` (View Rendering Logic):*

 ** `homeView.js`:
  *** `renderHomeView(appContainer)`: Renders the main layout for the home page (playlist list, song upload, new playlist sections, reorder modal structure).
  *** `renderSongs(appContainer, songWithAlbums)`: Renders songs with checkboxes for the "Create New Playlist" form.
  *** `renderPlaylists(appContainer, playlists)`: Renders the user's playlist list.
  *** `renderSongUploadSection(sectionContainer, genres, albumSummaries, error, formId, errorDivId)`: Renders the song upload form.
  *** `createReorderPopup()`: Creates the HTML structure for the reorder playlist modal's content.
  *** `populateModal(orderedSongs, modalContent)`: Fills the reorder modal with draggable song items.

 ** `loginView.js`:
  *** `renderLoginView(appContainer)`: Renders the login form and a link to the signup page.
  *** `renderSignupView(appContainer)`: Renders the signup form and a link to the login page.

 ** `playlistView.js`:
  *** `renderPlaylistView(appContainer)`: Renders the main layout for the playlist page (song slider, add song form).
  *** `writeSliderHeader(text)`: Sets the title for the playlist's song slider.
  *** `renderButtons(page, totPages)`: Manages visibility of pagination buttons for the song slider.
  *** `renderSongs(appContainer, songWithAlbums)`: Renders songs with checkboxes for the "Add Song to Playlist" form.
  *** `renderSliderItem(songWithAlbum)`: Creates an HTML element for a single song in the playlist slider.

 ** `sharedComponents.js`:
  *** `createSongUploadFormElement(formId, genres, albumSummaries, error)`: Creates a reusable song upload form element.
  *** `createSongArticleWithCheckboxElement(songWithAlbum)`: Creates a reusable song item display with a checkbox.

 ** `songsView.js`:
  *** `renderSongsView(appContainer)`: Renders the main layout for the "All Songs" page (song list, song upload form).
  *** `renderSongUploadSectionOnSongsPage(sectionContainer, genres, albumSummaries, error, formId, errorDivId)`: Renders the song upload form on the "All Songs" page.
  *** `renderAllUserSongsList(songListContainer, songs, error)`: Renders the list of all user songs, with each item clickable for playback.

* *`utils/` (Utility Functions):*

 ** This directory contains helper modules that provide common, reusable functionalities to support other parts of the application.

  *** `viewUtils.js`: DOM manipulation helpers (e.g., `createElement` for creating elements, functions to clear containers).
  *** `formUtils.js`: Utilities for form validation, data extraction from forms, or resetting forms.
  *** `delayUtils.js`: Functions for adding artificial delays, possibly for UI effects or simulating network latency during development/testing.
  *** `orderUtils.js`: Provides utilities to support drag-and-drop reordering logic for song lists, particularly within the reorder modal.

<<<

== Testing tools

* *Unit testing DAOs:* Junit 5
* *Generating mock data:* `mvn compile exec:java -Pgenerate`
* *Deleting mock data:* `mvn compile exec:java -Pcleanup`
